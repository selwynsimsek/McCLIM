#+title: SDL2 backend architecture
#+author: Daniel 'jackdaniel' KochmaÅ„ski
#+date: [2022-04-12 wto]

* Introduction

  SDL2 is a fine choice for an interactive and portable backend. The
  abstraction is thin and the library supports all major operating systems.
  The main limitation of the library is that it is not thread safe - all SDL2
  functions are expected to be called from a single thread (pushing events is
  an exception).

  In Common Lisp ecosystem there is a library ~cl-sdl2~ that proposes some
  abstractions over a "raw" SDL2 library. This backend relies on ~cl-sdl2~ for
  ffi bindings (generated with autowrap) provided by it, but I will mostly
  ignore ~cl-sdl2~ abstractions (some are used as a temporary measure).

  This document purpose is to emphasize important features that each backend
  must or should implement. Many sdl2-specific details are not explained and
  the reader should read the code to understand them. Keep in mind that most
  of these recommendations are a result of figuring things out while writing
  this backend - this is not a definitive guide.

* Syntactic sugar

  There are two approaches to ensure that SDL2 runs in a single thread.

  1. have a singular loop and communicate with it using a thread-safe channel
  2. assume that the environment is single-threaded

  McCLIM works fine with either model. That demands from the syntactic sugar
  to enable either style of interaction. For the multithreaded environment
  some synchronization primitives are introduced (most notably a condition
  variable to notify that the display server is already initialized).

  #+begin_src lisp
    (defvar *initialized-p* nil)
    (defvar *initialized-cv* (clim-sys:make-condition-variable))
    (defvar *initialized-lock* (clim-sys:make-lock "SDL2 init cv lock"))

    (defun %init-sdl2 ()
      (unless *initialized-p*
        (sdl2-ffi.functions:sdl-init (autowrap:mask-apply 'sdl-init-flags '(:everything)))
        (setf *initialized-p* t)
        (clim-sys:condition-notify *initialized-cv*)
        (log:info "Hello!")))

    (defun %quit-sdl2 ()
      (when *initialized-p*
        (log:info "Good bye.")
        (setf *initialized-p* nil)
        (sdl2-ffi.functions:sdl-quit)))

    (defun %read-sdl2 (event timeout)
      (let ((rc (if (null timeout)
                    (sdl2-ffi.functions:sdl-wait-event event)
                    (sdl2-ffi.functions:sdl-wait-event-timeout event timeout))))
        (= rc 1)))

    ;;; This implements semantics of process-next-event but without distributing
    ;;; the event - there is no need for the port argument.
    (defun %next-sdl2 (wait-function timeout)
      (when (maybe-funcall wait-function)
        (return-from %next-sdl2 (values nil :wait-function)))
      (sdl2:with-sdl-event (event)
        (alx:if-let ((ev (%read-sdl2 event timeout)))
          (let ((event-type (sdl2:get-event-type event)))
            (values (handle-sdl2-event event-type event) event-type))
          (if (maybe-funcall wait-function)
              (values nil :wait-function)
              (values nil :timeout)))))
  #+end_src

  The function ~handle-sdl2-event~ is used to implement event handling. When
  function that reads events calls ~handle-sdl2-event~ to dispatch on them.
  Methods for this function are defined with a macro ~define-sdl2-handler~.
  For example:

  #+begin_src lisp
    ;;; User-requested exit - this event is usually signaled when the last window
    ;;; is closed (in addition to windowevent/close), but may be also prompted by
    ;;; the window manager or an interrupt. The application may ignore it.
    (defvar *quit-stops-the-port-p* nil)

    (define-sdl2-handler (event :quit) ()
      (log:info "Quit requested... ~a"
                (if *quit-stops-the-port-p* "signaling" "ignoring"))
      (when *quit-stops-the-port-p*
        (signal 'sdl2-exit-port)))
  #+end_src

  The second argument to the macro is a list of arguments. The event is
  destructured (with the library ~autowrap~) to estabilish a lexical context
  for the handler body. For details see ~expand-handler-for-core-event~.

  To communicate with the main thread another convenience macro is defined:
  ~define-sdl2-request~. For example:

  #+begin_src lisp
    (define-sdl2-request sdl2-exit-port ()
      (signal 'sdl2-exit-port))
  #+end_src

  This macro registers an user event type, defines a function ~sdl2-exit-port~
  that queues event of that type and a method on ~handle-sdl2-event~ that
  implements the body. In single-processing mode handler is called directly.

  The arglist is similar as with the "system events" but we expand them by a
  different mechanism. Request lambda list is (,@args &key synchronize) - the
  keyword argument allows to wait for the result returned by the handler.

  #+begin_src lisp
    ;;; This function should be called with synchronization as a timeout - it will
    ;;; return :pong only when the event is processed (so the loop is processing).
    (define-sdl2-request sdl2-ping ()
      :pong)

    ;;; This function is for testing.
    ;;; WARNING this will freeze the event loop for requested amount of time.
    (define-sdl2-request sdl2-delay (ms)
      (sdl2:delay ms)
      :done)
  #+end_src

  #+begin_example
    MCCLIM-SDL2> (sdl2-ping)                       ;; NIL
    MCCLIM-SDL2> (sdl2-ping :synchronize t)        ;; :PONG
    MCCLIM-SDL2> (sdl2-delay 1000)                 ;; NIL
    MCCLIM-SDL2> (sdl2-delay 1000 :synchronize .5) ;; NIL
    MCCLIM-SDL2> (sdl2-delay 1000 :synchronize 2)  ;; :DONE
  #+end_example

  That concludes the syntactic sugar used by this project. The see
  implementation details see the file ~utilities.lisp~.

* Implementing the port

  The class ~sdl2-port~ represents a connection with the display server. Since
  there may be only one SDL2 context, it is shared by all instances the port
  by class-allocating relevant slots.

  Main functions that must be implemented by the port are:
  - initialize-instance that starts the port
  - destroy-port that stops it
  - restart-port that stops (when running) and resumes the port
  - process-next-event that reads and distributes events

  The function ~process-next-event~ has two keyword parameters ~wait-function~
  and ~timeout~. When running in a single process these parameters may be used
  to implement semantics of the event queue (and ~stream-read-gesture~).

  ~wait-function~ requires some additional commentary. It is a predicate that
  returns ~t~ when the caller doesn't wait for the input anymore (even if
  there is no event to be distributed). This function is called by the port at
  least once, but may be called multiple times while reading the event. Some
  "host" events may not be mapped to "clim" events, but they may mutate a
  state that is checked by the ~wait-function~.

  ~process-next-event~ reads host events until the clim event is returned or
  either the wait function or the timeout is reached:

  #+begin_src lisp
    (defmethod process-next-event ((port sdl2-port) &key wait-function timeout)
      (let ((*sdl2-port* port))
        (loop (multiple-value-bind (result reason)
                  (%next-sdl2 wait-function timeout)
                (cond ((eventp result)
                       (distribute-event port result)
                       (return-from process-next-event
                         (values t reason)))
                      ((member reason '(:wait-function :timeout))
                       (return-from process-next-event
                         (values result reason))))))))
  #+end_src

  The event loop provides a simple restart to ignore an error. Additionally
  when the error is signaled in the request that is synchronized, then the
  condition is returned as a value. In the future it is worth considering to
  differentiate in the event loop between "critical" host errors that invoke
  the debugger and "non-critical" user errors that are either quietly ignored
  (by the event loop) or logged.

  #+begin_src lisp
    (defun %loop-port (port)
      (%init-sdl2)
      (unwind-protect
           (handler-bind ((sdl2-exit-port
                            (lambda (c)
                              (declare (ignore c))
                              (return-from %loop-port))))
             (loop
               (with-simple-restart (ignore "Ignore error and continue.")
                 (process-next-event port))))
        (%quit-sdl2)))
  #+end_src

  When the port is run on a single-threaded host then the loop above is not
  started by the port, instead it is the user (i.e clim event queue) calls
  ~process-next-event~ when it waits for input.
